.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "QUEST 1"
.TH QUEST 1 "2013-11-20" "http://www.cs.uni-sb.de/~lindig" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
quest \-\- extensible test\-code generator for C compilers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBquest\fR [\fB\-test\fR \fItest\fR] [\fB\-n\fR \fInumber\fR] [\fB\-s\fR \fIdepth\fR]
[\fB\-1\fR|\fB\-2\fR] [\fB\-o\fR \fIbasename\fR] [\fB\-i\fR] [\fB\-e\fR \fILua chunk\fR]
[\fIx=y\fR] [\fIfile\fR\fB.lua\fR] [\fB\-seed\fR \fInumber\fR]
.PP
\&\fBquest \-list|\-lua|\-man|\-help|\-version\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Quest generates random C code to tests the parameter passing
implementation of a C compiler. When generated code is compiled and
executed, it checks that the values passed are actually the ones that
are expected. The generated code signals an error to stdout when it
finds parameter-passing bugs.
.PP
Quest can emit code into one or two C source files. Two files may be
compiled by different compilers to check their interoperability.  When
Quest generates code for two files, one file contains calling functions
and the other called functions.
.PP
Quest has an embedded interpreter for the scripting language Lua 2.5
that drives the top level of Quest. A user may add her own Lua code
to define additional test code generators. Adding a new test-code
generator is declarative and takes about 30 lines per generator.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-test\fR \fIsuite\fR" 4
.IX Item "-test suite"
Use the test-code generator \fIsuite\fR. Such a generator may be defined by
the user using the built-in Lua scripting language \*(-- see below. By
default, the \fBansi\fR generator is used. For a list of available
generators see the \fB\-list\fR option.
.IP "\fB\-list\fR" 4
.IX Item "-list"
List available test suites to stdout and quit.
.IP "\fB\-n\fR \fIint\fR" 4
.IX Item "-n int"
Test cases per file: the \fB\-n\fR flag indicates how many test cases per
file to generate. The default is 20.
.IP "\fB\-s\fR \fIint\fR" 4
.IX Item "-s int"
Test complexity: \fB\-s\fR indicates the complexity (or size) of the types
used in a test case. A C type has a tree structure with simple
types at the leaves and complex types like structs, pointers, and arrays
at the inner nodes. The size provided by \fB\-s\fR is the maximum depth of
such a tree; the default size is 2.
.Sp
Below are trees of depth 1, 2, and 3 to illustrate the concept of
depth; curly brackets denote structs and unions, a star denotes a
pointer type.
.Sp
.Vb 1
\&     0      1         2              3
\&    
\&    char    *         *              {}
\&            |         |             /  \e
\&           int        {}         int   {}
\&                     /  \e             /  \e
\&                  double int         *   char 
\&                                     |
\&                                    float
.Ve
.Sp
For example, with \fB\-s 0\fR all types are simple (scalar) types; with \fB\-s
1\fR a type may be a union or a pointer, but it must contain only simple
types.
.IP "\fB\-1\fR" 4
.IX Item "-1"
Generate code for one file (compilation unit) and write it to stdout;
this is the default.
.IP "\fB\-2\fR" 4
.IX Item "-2"
Generate code for two files (compilation units) whose names are
controlled by the \fB\-o\fR flag. No code is written to stdout.
.IP "\fB\-o\fR \fIname\fR" 4
.IX Item "-o name"
When generating code for two files, write them to \fIname\fR\f(CW\*(C`\-main.c\*(C'\fR and
\&\fIname\fR\f(CW\*(C`\-callee.c\*(C'\fR; the default for \fIname\fR is \f(CW\*(C`quest\*(C'\fR and the two
default files are thus \f(CW\*(C`quest\-main.c\*(C'\fR and \f(CW\*(C`quest\-callee.c\*(C'\fR. The
\&\f(CW\*(C`quest\-main.c\*(C'\fR file contains the \f(CW\*(C`main()\*(C'\fR function of the program that
results from compiling and linking these two files together.
.IP "\fB\-try\fR \fIgen\fR" 4
.IX Item "-try gen"
Instead of generating code, print the C types generated by generator
\&\fIgen\fR to stdout. The generator \fIgen\fR must be specified as a Lua
variable, e.g. \f(CW\*(C`Test.ansi.result\*(C'\fR and is \fBnot\fR the same a test suite as
accepted by option \fB\-test\fR. The options \fB\-s\fR, \fB\-n\fR are honored.  The
following example prints three C types, generated by the generator for
return types that is part of the \fB\-test ansi\fR suite. See section also
\&\s-1TYPE\s0 \s-1GENERATORS\s0 \s-1IN\s0 \s-1LUA\s0.
.Sp
.Vb 4
\&    $ quest \-n 3 \-s 1 \-try Test.ansi.result
\&    double
\&    union at2 { char cv2; double bv2; float av2; }
\&    double *
.Ve
.IP "\fIx=y\fR" 4
.IX Item "x=y"
An assignment (containing an \fB=\fR) is considered a Lua code chunk and is
passed to the interpreter for evaluation. This is a short form for \fB\-e\fR
\&\fIx=y\fR to simplify assigning a value to a Lua variable from the command
line:
.Sp
.Vb 4
\&    $ quest \-n 3 \-s 0 \*(Aqfoo=R.oneof{R.any_int,R.any_float}\*(Aq \-try foo
\&    char
\&    double
\&    float
.Ve
.IP "\fB\-e\fR \fIchunk\fR" 4
.IX Item "-e chunk"
Evaluate the Lua code \fIchunk\fR in the interpreter before generating test
cases. This can be used to set (global) variables in the interpreter
that test generators may rely on. However, \fIchunk\fR may be arbitrary
code, not just assignments. This option may be repeated; chunks are
evaluated from left to right.
.IP "\fIfile\fR\fB.lua\fR" 4
.IX Item "file.lua"
Load and execute \fIfile.lua\fR as Lua code. Use this option to add new
code generators to Quest or to override the built-in Lua code.
Evaluation order is as follows: first the built-in Lua code is loaded
into the interpreter and then the command line is evaluated from left to
right. This honors all assignments (\fIx=y\fR), \fB\-e\fR chunks, and files
\&\fIfile\fR\fB.lua\fR in left-to-right order.
.IP "\fB\-lua\fR" 4
.IX Item "-lua"
Dump the built-in Lua code to stdout. This permits to inspect the Lua
code that drives the application internally.
.IP "\fB\-seed\fR \fIint\fR" 4
.IX Item "-seed int"
Use \fIint\fR to seed the pseudo-random generator. The default is to use an
automatically chosen seed. A user-provided seed is useful for debugging
because it leads to the same output in two different program runs. A
seed may be negative.
.Sp
Each test case contains its seed as a comment. So when a
test case among many in a file has failed you can create a small file
with just that test case using \fB\-seed\fR and \fB\-n 1\fR. Of course, you have
to use otherwise the same options that were used to generate the
original file. These options are included as a comment at the beginning
of each file.
.Sp
The seed controls the types of a test case, but not the values that are
used for initializations. Two test cases generated with the same thus
may differ in their values. This may change in a future version.
.IP "\fB\-h\fR | \fB\-help\fR" 4
.IX Item "-h | -help"
Emit help message to stdout.
.IP "\fB\-version\fR" 4
.IX Item "-version"
Emit version information to stdout.
.SH "SIMPLE EXAMPLES"
.IX Header "SIMPLE EXAMPLES"
.IP "1." 4
.Vb 1
\&    quest > t.c
.Ve
.Sp
Emit one test file with 20 test cases to stdout.
.IP "2." 4
.Vb 1
\&    quest \-s 1 > t.c.
.Ve
.Sp
Emit one test file with 20 test cases of reduced complexity to stdout.
.IP "3." 4
.Vb 1
\&    quest \-2 \-test gcc
.Ve
.Sp
Emit two files, \f(CW\*(C`quest_callee.c\*(C'\fR and \f(CW\*(C`quest_main.c\*(C'\fR with 20 test cases that
may contain empty structs and arrays (as they are accepted by \fIgcc\fR\|(1)).
.IP "4." 4
.Vb 1
\&    quest \-2 \-o ttt \-n 100
.Ve
.Sp
Emit two files \f(CW\*(C`ttt_callee.c\*(C'\fR and \f(CW\*(C`ttt_main.c\*(C'\fR with 100 test cases.
.SH "ADVANCED EXAMPLES"
.IX Header "ADVANCED EXAMPLES"
The command sequence below for \fIsh\fR\|(1) is a quick way to test a C
compiler:
.PP
.Vb 6
\&    while true; do
\&        quest > quest.c
\&        cc \-o xxx \-O2 quest.c || break
\&        ./xxx || break
\&        echo \-n .
\&    done
.Ve
.PP
The loop runs until either the compiler fails or the quest-generated
generated code detects a bug in the compiler. The echo command is there
just to indicate some progress.
.PP
When a bug is found you can inspect the code surrounding the reported
line. There you will find a \f(CW\*(C`seed\*(C'\fR number. You can use this to
re-create a file with just the single test case that failed. Assuming
the seed was 12345, the following command will create a file with just a
single test case.
.PP
.Vb 1
\&    quest \-seed 12345 \-n 1 > quest\-12345.c
.Ve
.PP
It is important that you use the same options as before (with the
exception of \f(CW\*(C`\-n\*(C'\fR and \f(CW\*(C`\-seed\*(C'\fR) to re-create a test case when using a
seed.
.SH "TYPE GENERATORS IN LUA"
.IX Header "TYPE GENERATORS IN LUA"
Quest contains an embedded interpreter for the Pascal-like scripting
language Lua. It controls Quest's high-level behavior and is used to
define test code generators. Instead of using the built-in Lua code, a
user may supply her own code and thus new test-code generators. Before
reading on it is a good idea to read the Lua 2.5 reference manual that
comes with Quest, and to study the built-in Lua code, which may be
obtained with \f(CW\*(C`quest \-lua\*(C'\fR.
.PP
All test cases are derived from  function signatures (i.e., the return
and parameter types). These are generated by scripted generators. To
define a new test code generator it thus suffices to define a generator
for C types.
.PP
A generator is a Lua value, which, when run, produces a C type. A
generator is built from simpler generators; the simplest generators are
for scalar C types. A generator has its own type in Lua. Like tables,
generators are polymorphic: a generator may produce numbers, or strings,
or a mixture of both, it may even produce another generator. Most
generators produce only values of one kind. Specifically, we call a
type-generating generator a \fItypegen\fR, and a number-generating
generator an \fIintgen\fR, and so on.
.PP
.Vb 1
\&    R = Rand    \-\- abbreviation
\&
\&    \-\- all generators below are typegens.
\&    R.char
\&    R.short
\&    R.int
\&    R.long
\&    R.longlong
\&    R.float
\&    R.double
\&    R.longdouble
.Ve
.PP
When such a generator is run (using \f(CW\*(C`R.run\*(C'\fR), it produces the
corresponding (signed) type. Below is an interactive session with the
Lua interpreter where we used \f(CW\*(C`print\*(C'\fR to show the result of a
generator.
.PP
.Vb 8
\&    $ quest \-i
\&    \-\- $Id: quest.pod 4 2006\-11\-09 12:02:13Z lindig $
\&    \-\- This is Lua\-ML for Quest
\&    > R = Rand
\&    > u = Uniq.make()    
\&    > print(R.run(R.char,u,3))
\&    char
\&    >
.Ve
.PP
A generator for an unsigned type may be
derived from a generator for a signed type, using
\&\f(CW\*(C`R.unsigned(typegen)\*(C'\fR; this works for all integer\- and char-producing
generators from above.
.PP
.Vb 1
\&    R.unsigned(R.char)  \-\- typegen
.Ve
.PP
A complex type is a type that has other types embedded, like arrays,
structs, unions, and pointers. The generators for these types takes
another generator as argument to produce the embedded type:
.PP
.Vb 1
\&    R.pointer(R.char)   \-\- typegen
.Ve
.PP
The code above is a character-pointer generator. Obviously such a
generator is not very interesting, because it produces the same type
in every run. Variation comes from generators that select a generator
randomly from a list of generators:
.PP
.Vb 1
\&    R.pointer(R.oneof {R.char, R.int, R.long}) \-\- typegen
\&
\&    > print(R.run(R.pointer(R.oneof{R.char, R.int, R.long}),u,3))
\&    int *
\&    > print(R.run(R.pointer(R.oneof{R.char, R.int, R.long}),u,3))
\&    long int *
\&    > print(R.run(R.pointer(R.oneof{R.char, R.int, R.long}),u,3))
\&    int *
.Ve
.PP
The generator \f(CW\*(C`R.oneof(typegen list)\*(C'\fR takes a list of generators and
selects in each run one randomly. The generator above thus generates
pointers to characters, integers, and longs.
.PP
A generator may produce values other than C types: the generator
\&\f(CW\*(C`R.integer(n)\*(C'\fR generates a (random) integer in the range 0 to n\-1.
Such an \fIint_gen\fR generator is required to decide the size of an array:
.PP
.Vb 1
\&    R.array(R.char, R.integer(5))
.Ve
.PP
Don't confuse generator \f(CW\*(C`R.integer\*(C'\fR with generator \f(CW\*(C`R.int\*(C'\fR. The former
generates a (Lua) number, the latter a (C) type.
.PP
.Vb 6
\&    > print(R.run(R.array(R.char, R.integer(5)),u,3))            
\&    char [4]
\&    > print(R.run(R.array(R.char, R.integer(5)),u,3))
\&    char [2]
\&    > print(R.run(R.array(R.char, R.integer(5)),u,3))
\&    char [3]
.Ve
.PP
The generator above produces character arrays of size 0 to 4. Since a
size of zero is illegal in \s-1ANSI\s0 C, we also have integer generators that
permit to specify a lower bound too: \f(CW\*(C`R.choose(1,5)\*(C'\fR produces an
integer in the range 1 to 5 inclusive. A better generator thus would be:
.PP
.Vb 2
\&    simple = R.oneof {R.char, R.int, R.unsigned(R.int)}
\&    R.array(R.oneof{simple, R.choose(1,5))
.Ve
.PP
Here we have assigned a generator to a variable and used it in the
construction of the array generator. The is perfectly legal because
a generator is a Lua value and may be assigned to a variable, passed to
or returned from a function.
.PP
By now you should have a good idea how generators are built and how to
use additional generators. The generators for structs and unions take
generators that produce lists of types. These are built with \f(CW\*(C`R.list\*(C'\fR,
which takes two generators: one for integers, and one for types. The
integer generator controls the length of the list, the type generator is
used to fill the list with the appropriate number of types.
.PP
.Vb 3
\&    R.union(typelistgen)   \-\- generate unions
\&    R.struct(typelistgen)  \-\- generate structs
\&    R.list(intgen,typegen) \-\- generate list of types
.Ve
.PP
We are now ready to look at the definition of a real generator
\&\f(CW\*(C`ANSI.result\*(C'\fR for the return type of a C function.
.PP
.Vb 10
\&    ANSI.simple  = R.oneof {R.any_int, R.any_float }
\&    ANSI.members = R.choose(1,3)
\&    function ANSI.result_ (issimple)
\&        if issimple then
\&            return ANSI.simple
\&        else 
\&            return R.smaller 
\&            { R.any_int
\&            , R.any_float
\&            , R.pointer(ANSI.result)
\&            , R.struct(R.list(ANSI.members,ANSI.arg))
\&            , R.union(R.list(ANSI.members,ANSI.arg))
\&            }
\&        end     
\&    end    
\&    ANSI.result = R.bind(R.iszero,ANSI.result_) \-\- just use it this way
.Ve
.PP
A type in general is recursive and thus generators are recursive too.
However, we cannot define recursive generators directly because of the
eager evaluation of function arguments in Lua (and most other
languages). We thus have to use a little indirection. The generator must
also limit the recursion during the construction to ensure termination.
Function \f(CW\*(C`ANSI.result_\*(C'\fR receives a boolean value that tells whether
it should produce a simple value (and thus end recursion), or a complex
value. In either case, it returns a generator.
.PP
In the simple case, the generator returns an integer or float.
(\f(CW\*(C`R.any_int\*(C'\fR and \f(CW\*(C`R.any_float\*(C'\fR are predefined.) In the complex case,
the generator produces and integer, float, struct, or union, but no
array because these are illegal in return types. The \f(CW\*(C`R.smaller\*(C'\fR
generator ensures that the size of the generated types becomes
smaller with deeper recursion.
.PP
A test suite is a table of four generators: one for regular arguments,
one used for var args, one for the result type, and one for the scope of
the function under test. The scope can be static or public. Since a
static function may be called using a different calling convention than
a public function, some variation is useful. We use the \f(CW\*(C`flip\*(C'\fR
generator for the scope, which returns a boolean value. The generator
for \f(CW\*(C`static\*(C'\fR is ignored when code is emitted into two files; all
functions under are declared public in this case, since they would not
be visible for the caller otherwise.
.PP
This table must be returned by a function that expects no arguments.
.PP
.Vb 7
\&    function ANSI.test () return
\&        { args       = R.list(R.choose(1,4),ANSI.arg)
\&        , varargs    = R.list(R.unit(0),R.int)  \-\- var args
\&        , result     = ANSI.result
\&        , static     = R.flip \-\- generates bool
\&        }
\&    end
.Ve
.PP
The generator for parameter lists uses the \f(CW\*(C`ANSI.arg\*(C'\fR generator for
each parameter (which we haven't shown); it used to produce a list of
parameters, where the list contains between 1 and 4 parameter types.
The list for var args always has zero elements and the generator for the
result type is the one defined above.
.PP
To make a generator accessible for the \fB\-test\fR command line option, it
must be placed  into the \f(CW\*(C`Test\*(C'\fR table. The generator above is thus
available as \fB\-test ansi\fR.
.PP
.Vb 4
\&    Test.ansi = 
\&        { doc   = "ANSI C, but no var args"
\&        , test  = ANSI.test
\&        }
.Ve
.PP
To see the actual Lua code used in Quest, use \f(CW\*(C`quest \-lua\*(C'\fR that dumps
it to stdout. To add your own code, write it into a file \f(CW\*(C`my.lua\*(C'\fR and
pass this file as \f(CW\*(C`quest my.lua\*(C'\fR to Quest. For a start, it is a good
idea to extract the code in the \f(CW\*(C`Demo\*(C'\fR table from the \f(CW\*(C`Quest \-lua\*(C'\fR
output, to modify it, and to pass it back into the interpreter on the
command line.
.SH "VAR ARGS"
.IX Header "VAR ARGS"
A function using varargs must have at least one regular argument (c.f.
the documentation for \fBstdarg.h\fR); all test cases violating this
requirement are dropped with a warning. The var args generator for the
\&\f(CW\*(C`ansi\*(C'\fR generator is \f(CW\*(C`Test.ansi.test.varargs\*(C'\fR, the corresponding
generator \f(CW\*(C`Test.ansi.test.args\*(C'\fR for regular arguments thus must be
defined to produce at least a list of length one.
.SH "PRIMITIVE GENERATORS"
.IX Header "PRIMITIVE GENERATORS"
This section lists the primitive and complex generators that are built
into Quest and which can be used to define new generators. The following
generators are in Table \f(CW\*(C`Rand\*(C'\fR (which we abbreviated above as \f(CW\*(C`R\*(C'\fR).
.PP
.Vb 5
\&    unit(value)             \-\- generator that always returns value
\&    bind(gen,function)      \-\- give function access to value from gen
\&    run(gen,uniq,number)    \-\- run generator, asking for for result of size
\&    smaller(gen list)       \-\- select gen from list, ask for smaller size
\&    iszero                  \-\- boolean generator, signals end of recursion
\&
\&    flip                    \-\- bool generator
\&    integer(number)         \-\- integer generator, range 0 .. number\-1
\&    choose(number,number)   \-\- integer generator, range low .. high
\&    elements(value list)    \-\- generator producing value from list
\&    oneof(gen list)         \-\- generator selecting generator from list
\&    list(intgen, gen)       \-\- generate list (length by intgen) using gen
\&    freq(pairs)             \-\- see below
\&    concat(gen list)        \-\- takes list of list\-generating generators
\&                               and builds a single list\-generating generator
\&
\&    char                    \-\- C char generator
\&    short                   \-\- C short generator
\&    int                     \-\- C int generator
\&    long                    \-\- C long generator
\&    longlong                \-\- C longlong generator
\&    bitfield(intgen)        \-\- C bitfield of given width
\&
\&    unsigned(typegen)       \-\- generate unsigned values
\&
\&    float                   \-\- C float generator
\&    double                  \-\- C double generator
\&    longdouble              \-\- C long double generator
\&    any_int                 \-\- generates an int type
\&    any_float               \-\- generates a float type
\&
\&    array(typegen,intgen)   \-\- C array of intgen length
\&    pointer(typegen)        \-\- C pointer type generator 
\&    struct(typelistgen)     \-\- C struct type generator (intgen members)
\&    union(typelistgen)      \-\- C union type generator  (intgen members)
.Ve
.PP
Note that bitfields are legal only as part of a structure or union.
.PP
Generators like \f(CW\*(C`oneof\*(C'\fR or \f(CW\*(C`elements\*(C'\fR select generators or values from
a list with equal probability. The \f(CW\*(C`freq\*(C'\fR generator permits to specify
a biased choice:
.PP
.Vb 5
\&    R.freq 
\&        { 1, char
\&        , 3, int
\&        , 5, float
\&        }
.Ve
.PP
It takes a list of integer/generator pairs. The integer defines a weight
for the choice; hence, the \f(CW\*(C`float\*(C'\fR generator is chosen 5 out of 9 times
(1+3+5=9).
.PP
Function \f(CW\*(C`run\*(C'\fR is used mostly internally; it takes a name generator and
a size as arguments, where the size defines the maximum depth of a type.
This size is the same that is also specified on the command line. A
generator for unique names is returned by \f(CW\*(C`Uniq.make()\*(C'\fR.
.PP
Function \f(CW\*(C`bind\*(C'\fR is also used mostly internally. It gives a function
access to a value a generator has produced when the generator is run.
This was used in the example above to give the \f(CW\*(C`Ansi.result_\*(C'\fR function
access to the result of \f(CW\*(C`iszero\*(C'\fR. Once \f(CW\*(C`iszero\*(C'\fR produces true in a
run, recursion must stop.
.PP
The ultimate resource for the list of available generators and other
primitive Lua functions is the source code of Quest's implementation:
module \fIlualink.nw\fR.
.SH "THE GENERATED CODE"
.IX Header "THE GENERATED CODE"
A file generated by \fBquest\fR typically contains a number of test cases.
Each test case defines some possibly complex global variables.  These
are automatically initialized with random values using C initializers .
.PP
.Vb 6
\&    int x0 = 5;
\&    int x1[2] = {38, 2};
\&    struct s {
\&        char c;
\&        int  i;
\&    } x2 = { \*(Aqc\*(Aq, 77 };
.Ve
.PP
A generated function with corresponding parameters expects these
variables to be passed; the body of the function checks that the values
actually passed are indeed the ones expected.
.PP
.Vb 8
\&    void f(int a0, int a1[2], struct s a2)
\&    {
\&        if (a0 != x0) failed(_\|_LINE_\|_);
\&        if (a1[0] != x1[0]) failed(_\|_LINE_\|_);
\&        if (a1[1] != x1[1]) failed(_\|_LINE_\|_);
\&        if (a2.c != x2.c) failed(_\|_LINE_\|_);
\&        if (a2.i != x2.i) failed(_\|_LINE_\|_);
\&    }
.Ve
.PP
If the function finds an unexpected value passed in a parameter, it
calls \f(CW\*(C`failed()\*(C'\fR.  The \f(CW\*(C`failed()\*(C'\fR function emits an error message
indicating the file and line number of the error.
.PP
For each function \f(CW\*(C`f\*(C'\fR, a corresponding function \f(CW\*(C`g\*(C'\fR is generated that
passes the global variables by value to \f(CW\*(C`f()\*(C'\fR.
.PP
.Vb 4
\&    void g(void)
\&    {
\&        f(a0,a1,a2);
\&    }
.Ve
.PP
This function is called by the \f(CW\*(C`main()\*(C'\fR function when the test is run.
The \f(CW\*(C`main()\*(C'\fR function therefore just contains as many calls as there
are test cases in a file.
.PP
When the code is distributed over two files, \f(CW\*(C`f()\*(C'\fR and \f(CW\*(C`g()\*(C'\fR reside in
two different files; variable and function declarations as necessary are
declared to make the different parts known to each other.
.PP
The code above just illustrates the principle; the real code generated
uses less readable names to avoid name clashes.
.PP
The complexity of the types for global variables can be controlled by
the \fB\-s\fR flag. However, the exact distribution of types is currently
hard-coded into \fBquest\fR.
.SH "EXIT CODE"
.IX Header "EXIT CODE"
Upon successful execution, \fBquest\fR exists with exit code \f(CW0\fR. Wrong
usage leads to a positive error code, internal errors to a negative error
code.
.PP
The generated code contains a \f(CW\*(C`main\*(C'\fR function that returns the number
or errors found; hence it returns \f(CW0\fR for a successful test and a
positive number if it finds bugs.
.SH "BUGS"
.IX Header "BUGS"
When something goes wrong while executing Lua code, the Lua interpreter
emits a stack trace. From this it is sometimes difficult to figure
out the problem.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and experience reports to the author:
Christian Lindig <lindig@cs.uni\-sb.de>
http://www.st.cs.uni\-sb.de/~lindig/ <http://www.st.cs.uni-sb.de/~lindig/>
.PP
The Lua-ML interpreter was implemented by Norman Ramsey
<nr@eecs.harvard.edu> and is available from
<http://www.cminusminus.org/>. The Lua language was designed and
implemented by Roberto Ierusalimschy et al.; a C implementation of Lua
is available from <http://www.lua.org/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004, 2005 Christian Lindig <lindig@eecs.harvard.edu>. All
rights reserved.
.PP
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
.IP "1." 4
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
.IP "2." 4
Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.
.PP
\&\s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 ``\s-1AS\s0 \s-1IS\s0'' \s-1AND\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0
\&\s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1ARE\s0
\&\s-1DISCLAIMED\s0.  \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0 \s-1THE\s0 \s-1AUTHOR\s0 \s-1AND\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0 \s-1BE\s0
\&\s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1DIRECT\s0, \s-1INDIRECT\s0, \s-1INCIDENTAL\s0, \s-1SPECIAL\s0, \s-1EXEMPLARY\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 (\s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0,
\&\s-1PROCUREMENT\s0 \s-1OF\s0 \s-1SUBSTITUTE\s0 \s-1GOODS\s0 \s-1OR\s0 \s-1SERVICES\s0; \s-1LOSS\s0 \s-1OF\s0 \s-1USE\s0, \s-1DATA\s0, \s-1OR\s0
\&\s-1PROFITS\s0; \s-1OR\s0 \s-1BUSINESS\s0 \s-1INTERRUPTION\s0) \s-1HOWEVER\s0 \s-1CAUSED\s0 \s-1AND\s0 \s-1ON\s0 \s-1ANY\s0
\&\s-1THEORY\s0 \s-1OF\s0 \s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1CONTRACT\s0, \s-1STRICT\s0 \s-1LIABILITY\s0, \s-1OR\s0
\&\s-1TORT\s0 (\s-1INCLUDING\s0 \s-1NEGLIGENCE\s0 \s-1OR\s0 \s-1OTHERWISE\s0) \s-1ARISING\s0 \s-1IN\s0 \s-1ANY\s0 \s-1WAY\s0 \s-1OUT\s0 \s-1OF\s0
\&\s-1THE\s0 \s-1USE\s0 \s-1OF\s0 \s-1THIS\s0 \s-1SOFTWARE\s0, \s-1EVEN\s0 \s-1IF\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGE\s0.
.SH "VERSION"
.IX Header "VERSION"
.Vb 1
\& $Id: quest.pod 4 2006\-11\-09 12:02:13Z lindig $
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcc\fR\|(1), \fIgcc\fR\|(1), <http://www.lua.org/>, Lua 2.5 reference manual, \fIsh\fR\|(1)
